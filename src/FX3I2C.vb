'File:         FX3I2C.vb
'Author:       Alex Nolan (alex.nolan@analog.com)
'Date:         5/13/2020
'Description:  I2C interfacing for the FX3

Imports System.Collections.Concurrent
Imports System.Threading
Imports FX3USB
''' <summary>
''' I2C pre-amble class.
''' </summary>
Public Class I2CPreamble

    'private members
    Dim m_addr As Byte
    Dim m_stopMask As Byte
    Dim m_startMask As Byte

    ''' <summary>
    ''' I2C Preamble constructor. Initializes all fields to zero
    ''' </summary>
    Public Sub New()
        PreambleData = New List(Of Byte)
        m_addr = 0
        m_stopMask = 0
        m_startMask = 0
    End Sub

    ''' <summary>
    ''' The bytes to transmit following the device address and R/W bit.
    ''' The maximum size of this list is 7 bytes, giving 8 total bytes 
    ''' transmitted as part of the pre-amble.
    ''' </summary>
    Public PreambleData As List(Of Byte)

    ''' <summary>
    ''' This is the 7-bit slave address for the device to access on the I2C bus.
    ''' The address value must be left justified, with a zero in the least significant
    ''' bit. The address bits (starting at DeviceAddress bit 7) are the first data transmitted
    ''' by the FX3 when starting an I2C transaction. A R/W bit (generated by the firmware)
    ''' follows the seven device address bits to complete the first byte.
    ''' </summary>
    ''' <returns></returns>
    Public Property DeviceAddress As Byte
        Get
            Return m_addr
        End Get
        Set(value As Byte)
            'clear bit 0
            m_addr = CByte(value And &HFEUI)
        End Set
    End Property

    ''' <summary>
    ''' This field controls the stop condition sent after every byte of preamble
    ''' data. The device address is the first byte of data, following by up to 
    ''' seven additional bytes in PreAmbleData. For example, setting StopMask to
    ''' 0x01 will cause a stop condition to be generated after sending DeviceAddress, while
    ''' setting StopMask to 0x02 will cause a stop condition to be generated after 
    ''' sending PreambleData[0], and so on. Note, setting a bit in StopMask will cause 
    ''' the corresponding bit in StartMask to be cleared, if it is also set.
    ''' </summary>
    ''' <returns>The 8 bit preamble stop mask</returns>
    Public Property StopMask As Byte
        Get
            Return m_stopMask
        End Get
        Set(value As Byte)
            m_stopMask = value
            m_startMask = m_startMask And (Not m_stopMask)
        End Set
    End Property

    ''' <summary>
    ''' This field controls the start condition sent after every byte of preamble
    ''' data. The device address is the first byte of data, following by up to 
    ''' seven additional bytes in PreAmbleData. For example, setting StartMask to
    ''' 0x04 will cause a start condition to be generated after sending PreambleData[1], while
    ''' setting StartMask to 0x08 will cause a start condition to be generated after 
    ''' sending PreambleData[2], and so on. Note, setting a bit in StartMask will cause 
    ''' the corresponding bit in StopMask to be cleared, if it is also set.
    ''' </summary>
    ''' <returns>The 8 bit preamble start mask</returns>
    Public Property StartMask As Byte
        Get
            Return m_startMask
        End Get
        Set(value As Byte)
            m_startMask = value
            m_stopMask = m_stopMask And (Not m_startMask)
        End Set
    End Property

    ''' <summary>
    ''' Helper function to serialize an I2C preamble. Puts the 
    ''' preamble into a byte array which can be sent over USB
    ''' </summary>
    ''' <returns>Byte array containing the pre-amble</returns>
    Friend Function Serialize() As IEnumerable(Of Byte)

        'data array
        Dim data As New List(Of Byte)

        'preamble count
        Dim count As Integer

        'pre-amble length in first byte
        count = PreambleData.Count + 1
        'clamp at 8 bytes
        If count > 8 Then count = 8
        data.Add(CByte(count))

        'ctrl lower (start mask)
        data.Add(StartMask)

        'ctrl upper (stop mask)
        data.Add(StopMask)

        'dev addr
        data.Add(DeviceAddress)

        'pre-amble data
        If PreambleData.Count > 7 Then
            PreambleData.RemoveRange(7, PreambleData.Count - 7)
        End If
        data.AddRange(PreambleData)

        Return data

    End Function

End Class

Partial Class FX3Connection

    ''' <summary>
    ''' Get/Set the FX3 I2C bit rate. Valid range 100KHz - 1MHz. Defaults to 100KHz
    ''' </summary>
    ''' <returns>Current I2C bit rate setting</returns>
    Public Property I2CBitRate As UInteger
        Get
            Return m_i2cbitrate
        End Get
        Set(value As UInteger)
            'valid range 100KHz - 1MHz
            If value < 100000 Then Throw New FX3ConfigurationException("ERROR: Invalid I2C bit rate. Must be at least 100KHz")
            If value > 1000000 Then Throw New FX3ConfigurationException("ERROR: Invalid I2C bit rate. Must be at 1MHz or less")

            'send command to update FX3 I2C config
            SetI2CBitRate(value)

            'save setting
            m_i2cbitrate = value
        End Set
    End Property

    ''' <summary>
    ''' Get/Set the FX3 I2C retry count. This is the number of times the FX3
    ''' will retry a read/write when a NAK is received from the slave device
    ''' being addressed.
    ''' </summary>
    ''' <returns></returns>
    Public Property I2CRetryCount As UShort
        Get
            Return m_i2cRetryCount
        End Get
        Set(value As UShort)
            'send command to update FX3 I2C config
            SetI2CRetryCount(value)

            'save setting
            m_i2cRetryCount = value
        End Set
    End Property

    ''' <summary>
    ''' Read bytes from an I2C slave device attached to the FX3.
    ''' </summary>
    ''' <param name="Preamble">The I2C preamble to transmit at the start of the read operation</param>
    ''' <param name="NumBytes">The number of bytes to read over I2C after sending the preamble</param>
    ''' <param name="TimeoutInMs">Read timeout period, in ms</param>
    ''' <returns>The data read from the I2C slave device</returns>
    Public Function I2CReadBytes(Preamble As I2CPreamble, NumBytes As UInteger, TimeoutInMs As UInteger) As Byte()

        'transfer buffer
        Dim buf As New List(Of Byte)

        'status buffer
        Dim bulkBuf(511) As Byte

        'transfer size
        Dim transferSize As Integer

        'track if operation is done
        Dim transferDone, validTransfer As Boolean

        'track timeout
        Dim timer As New Stopwatch

        'num read bytes first (0 - 3)
        buf.Add(CByte(NumBytes And &HFFUI))
        buf.Add(CByte((NumBytes >> 8) And &HFFUI))
        buf.Add(CByte((NumBytes >> 16) And &HFFUI))
        buf.Add(CByte((NumBytes >> 24) And &HFFUI))

        'timeout (4 - 7)
        buf.Add(CByte(TimeoutInMs And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 8) And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 16) And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 24) And &HFFUI))

        'pre-amble
        buf.AddRange(Preamble.Serialize())

        'send I2C read command over control endpoint
        ConfigureControlEndpoint(USBCommands.ADI_I2C_READ_BYTES, True)
        If Not XferControlData(buf.ToArray(), buf.Count, 2000) Then
            Throw New FX3CommunicationException("ERROR: Control endpoint transfer timed out while starting I2C read command")
        End If

        'accumulate data over bulk endpoint
        transferDone = False
        buf.Clear()
        timer.Start()
        While (Not transferDone) And (timer.ElapsedMilliseconds < TimeoutInMs)
            'check if done
            If buf.Count >= NumBytes Then
                transferDone = True
            Else
                'get a block of data from bulk in endpoint
                transferSize = CInt(Math.Min(512, NumBytes - buf.Count))
                'transfer will run in 512 byte blocks until last transfer, which cleans up remaining data
                validTransfer = FX3USB.USB.XferData(bulkBuf, transferSize, DataInEndPt)
                If validTransfer Then
                    'add all the data received
                    For i As Integer = 0 To transferSize - 1
                        buf.Add(bulkBuf(i))
                    Next
                End If
            End If
        End While

        'check timeout
        If Not transferDone Then
            Throw New FX3CommunicationException("ERROR: I2C read timed out. Timeout period " + TimeoutInMs.ToString() + "ms")
        End If

        Return buf.ToArray()

    End Function

    ''' <summary>
    ''' Write bytes to an I2C slave device attached to the FX3
    ''' </summary>
    ''' <param name="Preamble">The I2C preamble to transmit at the start of the write operation</param>
    ''' <param name="WriteData">The write data to transmit on SDA after finishing the preamble</param>
    ''' <param name="TimeoutInMs">Write timeout period, in ms</param>
    Public Sub I2CWriteBytes(Preamble As I2CPreamble, WriteData As IEnumerable(Of Byte), TimeoutInMs As UInteger)

        'transfer buffer
        Dim buf As New List(Of Byte)

        'status buffer
        Dim statusBuf(3) As Byte

        'status
        Dim status As UInteger

        'track if operation is done
        Dim transferDone As Boolean

        'track timeout
        Dim timer As New Stopwatch

        'check that write data is less than (4096 - (11 + 4 + 4)) bytes
        If WriteData.Count > 4077 Then
            Throw New FX3ConfigurationException("ERROR: Invalid write data length. Cannot total command transfer size cannot be more than 4096 bytes")
        End If

        'write data length first (0 - 3)
        buf.Add(CByte(WriteData.Count And &HFFUI))
        buf.Add(CByte((WriteData.Count >> 8) And &HFFUI))
        buf.Add(CByte((WriteData.Count >> 16) And &HFFUI))
        buf.Add(CByte((WriteData.Count >> 24) And &HFFUI))

        'timeout (4 - 7)
        buf.Add(CByte(TimeoutInMs And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 8) And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 16) And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 24) And &HFFUI))

        'pre-amble
        buf.AddRange(Preamble.Serialize())

        'write data
        buf.AddRange(WriteData)

        'send I2C write command + data over control endpoint
        ConfigureControlEndpoint(USBCommands.ADI_I2C_WRITE_BYTES, True)
        If Not XferControlData(buf.ToArray(), buf.Count, 2000) Then
            Throw New FX3CommunicationException("ERROR: Control endpoint transfer timed out while starting I2C write command")
        End If

        'wait for done command from bulk endpoint
        transferDone = False
        timer.Start()
        While (Not transferDone) And (timer.ElapsedMilliseconds < TimeoutInMs)
            transferDone = FX3USB.USB.XferData(statusBuf, 4, DataInEndPt)
        End While

        'check timeout
        If Not transferDone Then
            Throw New FX3CommunicationException("ERROR: I2C write timed out. Timeout period " + TimeoutInMs.ToString() + "ms")
        End If

        'check status
        status = BitConverter.ToUInt32(statusBuf, 0)
        If status <> 0 Then
            Throw New FX3BadStatusException("ERROR: Bad status code after I2C write. Error code: 0x" + status.ToString("X4"))
        End If

    End Sub


    ''' <summary>
    ''' Helper function to set i2c bit rate on FX3
    ''' </summary>
    ''' <param name="BitRate">Bit rate setting</param>
    Private Sub SetI2CBitRate(BitRate As UInteger)

        'transfer buffer
        Dim buf(3) As Byte

        'status
        Dim status As UInteger

        'configure for i2c set bit rate command
        ConfigureControlEndpoint(USBCommands.ADI_I2C_SET_BIT_RATE, False)
        FX3ControlEndPt.Value = CUShort(BitRate And &HFFFFUI)
        FX3ControlEndPt.Index = CUShort((BitRate And &HFFFF0000UI) >> 16)

        'send command
        If Not XferControlData(buf, 4, 2000) Then
            Throw New FX3CommunicationException("ERROR: Control endpoint transfer timed out while setting I2C bit rate")
        End If

        'check status
        status = BitConverter.ToUInt32(buf, 0)
        If status <> 0 Then
            Throw New FX3BadStatusException("ERROR: Bad status code after setting I2C bit rate. Error code: 0x" + status.ToString("X4"))
        End If

    End Sub

    ''' <summary>
    ''' Helper function to set i2c retry count in case of NAK on FX3
    ''' </summary>
    ''' <param name="Count">Number of times to transfer</param>
    Private Sub SetI2CRetryCount(Count As UShort)

        'transfer buffer
        Dim buf(3) As Byte

        'status
        Dim status As UInteger

        'configure for i2c set bit rate command
        ConfigureControlEndpoint(USBCommands.ADI_I2C_RETRY_COUNT, False)
        FX3ControlEndPt.Value = Count

        'send command
        If Not XferControlData(buf, 4, 2000) Then
            Throw New FX3CommunicationException("ERROR: Control endpoint transfer timed out while setting I2C retry count")
        End If

        'check status
        status = BitConverter.ToUInt32(buf, 0)
        If status <> 0 Then
            Throw New FX3BadStatusException("ERROR: Bad status code after setting I2C retry count. Error code: 0x" + status.ToString("X4"))
        End If

    End Sub

#Region "I2C Streaming"

    ''' <summary>
    ''' Start an asynchronous I2C read stream. This stream runs on the stream thread
    ''' and places all data in a thread safe queue. The data can be retrieved using
    ''' GetI2CBuffer()
    ''' </summary>
    ''' <param name="Preamble">The preamble to send at the start of the read</param>
    ''' <param name="BytesPerRead">Number of read bytes following the preamble</param>
    ''' <param name="numBuffers">Total number of separate I2C transactions to send</param>
    Public Sub StartI2CStream(Preamble As I2CPreamble, BytesPerRead As UInteger, numBuffers As UInteger)

        'transfer buffer
        Dim buf As New List(Of Byte)

        'status buffer
        Dim bulkBuf(511) As Byte

        Dim TimeoutInMs As UInteger = CUInt(1000 * m_StreamTimeout)

        'num read bytes first (0 - 3)
        buf.Add(CByte(BytesPerRead And &HFFUI))
        buf.Add(CByte((BytesPerRead >> 8) And &HFFUI))
        buf.Add(CByte((BytesPerRead >> 16) And &HFFUI))
        buf.Add(CByte((BytesPerRead >> 24) And &HFFUI))

        'timeout (4 - 7)
        buf.Add(CByte(TimeoutInMs And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 8) And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 16) And &HFFUI))
        buf.Add(CByte((TimeoutInMs >> 24) And &HFFUI))

        'pre-amble
        buf.AddRange(Preamble.Serialize())

        'add numBuffers
        buf.Add(CByte(numBuffers And &HFFUI))
        buf.Add(CByte((numBuffers >> 8) And &HFFUI))
        buf.Add(CByte((numBuffers >> 16) And &HFFUI))
        buf.Add(CByte((numBuffers >> 24) And &HFFUI))

        'send I2C stream start command over control endpoint
        ConfigureControlEndpoint(USBCommands.ADI_I2C_READ_STREAM, True)
        m_ActiveFX3.ControlEndPt.Index = CUShort(StreamCommands.ADI_STREAM_START_CMD)
        If Not XferControlData(buf.ToArray(), buf.Count, 2000) Then
            Throw New FX3CommunicationException("ERROR: Control endpoint transfer timed out while starting I2C stream")
        End If

        'set buffers to read
        m_TotalBuffersToRead = numBuffers

        'Reset frame counter
        m_FramesRead = 0

        'Set the total number of frames to read
        m_TotalBuffersToRead = numBuffers

        'Reinitialize the data queue
        m_I2CStreamData = New ConcurrentQueue(Of Byte())

        'Set the stream type
        m_StreamType = StreamType.I2CReadStream

        'Start the i2c Stream Thread
        m_StreamThread = New Thread(AddressOf I2CStreamManager)
        m_StreamThread.Start(BytesPerRead)

    End Sub

    ''' <summary>
    ''' Stream thread function for I2C stream
    ''' </summary>
    ''' <param name="BytesPerBuffer">Number of bytes to read</param>
    Private Sub I2CStreamManager(BytesPerBuffer As Object)

        'Bool to track the transfer status
        Dim transferStatus As Boolean
        'transfer size
        Dim transferSize As Integer = CInt(BytesPerBuffer)
        'Buffer to hold data from the FX3
        Dim buf(transferSize - 1) As Byte
        'frame counter
        Dim frameCounter As UInteger

        '0 buffers -> infinite
        If m_TotalBuffersToRead < 1 Then
            m_TotalBuffersToRead = UInteger.MaxValue
        End If

        'Wait for previous stream thread to exit, if any
        m_StreamThreadRunning = False

        'Wait until a lock can be acquired on the streaming end point
        m_StreamMutex.WaitOne()

        'Set the stream thread running state variable
        m_StreamThreadRunning = True
        frameCounter = 0

        While m_StreamThreadRunning
            'transfer data from FX3
            transferStatus = USB.XferData(buf, transferSize, StreamingEndPt)
            'Parse bytes into frames and add to m_StreamData if transaction was successful
            If transferStatus Then
                m_I2CStreamData.Enqueue(buf.ToArray())
                RaiseEvent NewBufferAvailable(m_I2CStreamData.Count)
                frameCounter += 1UI
                'Increment the shared frame counter
                Interlocked.Increment(m_FramesRead)
            ElseIf m_StreamThreadRunning Then
                Console.WriteLine("Transfer failed during I2C stream. Error code: " + StreamingEndPt.LastError.ToString() + " (0x" + StreamingEndPt.LastError.ToString("X4") + ")")
                'send cancel command
                CancelStreamImplementation(USBCommands.ADI_I2C_READ_STREAM)
                'Exit streaming mode if the transfer fails
                Exit While
            Else
                'exiting due to cancel
                Exit While
            End If

            If frameCounter >= m_TotalBuffersToRead Then
                'Stop streaming
                I2CStreamDone()
                Exit While
            End If

        End While

        ExitStreamThread()

    End Sub

    ''' <summary>
    ''' Cleanup function when I2C stream is done
    ''' </summary>
    Private Sub I2CStreamDone()

        'Buffer to hold command data
        Dim buf(3) As Byte

        'Configure the control endpoint
        ConfigureControlEndpoint(USBCommands.ADI_I2C_READ_STREAM, True)
        m_ActiveFX3.ControlEndPt.Value = 0
        m_ActiveFX3.ControlEndPt.Index = CUShort(StreamCommands.ADI_STREAM_DONE_CMD)

        'Send command to the DUT to stop streaming data
        If Not XferControlData(buf, 4, 2000) Then
            Throw New FX3CommunicationException("ERROR: Timeout occurred when cleaning up I2C stream thread on the FX3!")
        End If

    End Sub

    ''' <summary>
    ''' Get I2C buffer from I2C read stream
    ''' </summary>
    ''' <returns>I2C data read</returns>
    Public Function GetI2CBuffer() As Byte()

        Dim buf As Byte() = Nothing

        If IsNothing(m_I2CStreamData) Then
            Return Nothing
        End If

        If m_I2CStreamData.Count = 0 Then Return Nothing

        m_I2CStreamData.TryDequeue(buf)
        Return buf

    End Function

#End Region

End Class
