<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADI iSensor FX3 Firmware: C:/Users/anolan3/Documents/iSensor-FX3-API/firmware/FX3_Firmware/main.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Analog-Devices-Logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADI iSensor FX3 Firmware
   &#160;<span id="projectnumber">v2.9.2-pub</span>
   </div>
   <div id="projectbrief">Firmware for the Analog Devices EVAL-ADIS-FX3 IMU Evaluation Platform. This firmware can be compiled using the Cypress EZ USB Suite IDE</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a6f5bf3126ac94fe2cad71d1f6aa3d6b.html">FX3_Firmware</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">main.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Entry point and setup functions for the Analog Devices iSensor FX3 Demonstration Platform firmware.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="main_8h_source.html">main.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae2dfaf6e49d51d401e281fbdf83d874"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#aae2dfaf6e49d51d401e281fbdf83d874">USBBuffer</a> ((aligned(32)))</td></tr>
<tr class="separator:aae2dfaf6e49d51d401e281fbdf83d874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add07376eecfcd79dfd9f998172675538"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#add07376eecfcd79dfd9f998172675538">BulkBuffer</a> ((aligned(32)))</td></tr>
<tr class="separator:add07376eecfcd79dfd9f998172675538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4f00a6649f71b6f7d737b7906b7ab3"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a1e4f00a6649f71b6f7d737b7906b7ab3">FirmwareID</a> ((aligned(32)))</td></tr>
<tr class="separator:a1e4f00a6649f71b6f7d737b7906b7ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944fb7c8896fdcd7f0d7d00f06fb329"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#af944fb7c8896fdcd7f0d7d00f06fb329">serial_number</a> ((aligned(32)))</td></tr>
<tr class="separator:af944fb7c8896fdcd7f0d7d00f06fb329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the main entry point function for the iSensor FX3 application firmware.  <a href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br /></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a66ed1cd4bddfaee4a19ede70f94cc1"><td class="memItemLeft" align="right" valign="top">CyBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a9a66ed1cd4bddfaee4a19ede70f94cc1">AdiControlEndpointHandler</a> (uint32_t setupdat0, uint32_t setupdat1)</td></tr>
<tr class="memdesc:a9a66ed1cd4bddfaee4a19ede70f94cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles events generated by the control endpoint. All vendor requests are handled in this function.  <a href="main_8c.html#a9a66ed1cd4bddfaee4a19ede70f94cc1">More...</a><br /></td></tr>
<tr class="separator:a9a66ed1cd4bddfaee4a19ede70f94cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2407e9fc4f519060a25f5e6e79c9908e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a2407e9fc4f519060a25f5e6e79c9908e">AdiBulkEndpointHandler</a> (CyU3PUsbEpEvtType evType, CyU3PUSBSpeed_t usbSpeed, uint8_t epNum)</td></tr>
<tr class="memdesc:a2407e9fc4f519060a25f5e6e79c9908e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles events generated by the bulk endpoint.  <a href="main_8c.html#a2407e9fc4f519060a25f5e6e79c9908e">More...</a><br /></td></tr>
<tr class="separator:a2407e9fc4f519060a25f5e6e79c9908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af455227720659b28782283fa0cafc5bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#af455227720659b28782283fa0cafc5bc">AdiUSBEventHandler</a> (CyU3PUsbEventType_t evtype, uint16_t evdata)</td></tr>
<tr class="memdesc:af455227720659b28782283fa0cafc5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a callback function to handle generic USB events.  <a href="main_8c.html#af455227720659b28782283fa0cafc5bc">More...</a><br /></td></tr>
<tr class="separator:af455227720659b28782283fa0cafc5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863fcc5229cc4a18aedee7cda44ea9a"><td class="memItemLeft" align="right" valign="top">CyBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a2863fcc5229cc4a18aedee7cda44ea9a">AdiLPMRequestHandler</a> (CyU3PUsbLinkPowerMode link_mode)</td></tr>
<tr class="memdesc:a2863fcc5229cc4a18aedee7cda44ea9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a callback function to handle Link Power Management (LPM) requests.  <a href="main_8c.html#a2863fcc5229cc4a18aedee7cda44ea9a">More...</a><br /></td></tr>
<tr class="separator:a2863fcc5229cc4a18aedee7cda44ea9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0012feb7c1973f17875ca9c3458462bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a0012feb7c1973f17875ca9c3458462bf">AdiGPIOEventHandler</a> (uint8_t gpioId)</td></tr>
<tr class="memdesc:a0012feb7c1973f17875ca9c3458462bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles GPIO interrupts and sets the appropriate flag in GpioHandler.  <a href="main_8c.html#a0012feb7c1973f17875ca9c3458462bf">More...</a><br /></td></tr>
<tr class="separator:a0012feb7c1973f17875ca9c3458462bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759bbcdd7e9e2d77fc72f1b1ed12c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a4759bbcdd7e9e2d77fc72f1b1ed12c1a">AdiAppErrorHandler</a> (CyU3PReturnStatus_t status)</td></tr>
<tr class="memdesc:a4759bbcdd7e9e2d77fc72f1b1ed12c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles critical errors generated by the ADI application.  <a href="main_8c.html#a4759bbcdd7e9e2d77fc72f1b1ed12c1a">More...</a><br /></td></tr>
<tr class="separator:a4759bbcdd7e9e2d77fc72f1b1ed12c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d56f1d4d6c6e069d5bed2d01c2fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a802d56f1d4d6c6e069d5bed2d01c2fbd">AdiAppStop</a> ()</td></tr>
<tr class="memdesc:a802d56f1d4d6c6e069d5bed2d01c2fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to shut down the application.  <a href="main_8c.html#a802d56f1d4d6c6e069d5bed2d01c2fbd">More...</a><br /></td></tr>
<tr class="separator:a802d56f1d4d6c6e069d5bed2d01c2fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ef5f1f7dd70bdb654bd2e0ed215a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a97ef5f1f7dd70bdb654bd2e0ed215a8e">AdiAppStart</a> ()</td></tr>
<tr class="memdesc:a97ef5f1f7dd70bdb654bd2e0ed215a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets up the necessary resources to start the ADI application.  <a href="main_8c.html#a97ef5f1f7dd70bdb654bd2e0ed215a8e">More...</a><br /></td></tr>
<tr class="separator:a97ef5f1f7dd70bdb654bd2e0ed215a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4e2d0388671969c6290eb9323066c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="main_8h.html#a5d0d41db1886fb75e6a09e4b74cdbc54">FX3BoardType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a3c4e2d0388671969c6290eb9323066c2">AdiGetFX3BoardType</a> ()</td></tr>
<tr class="memdesc:a3c4e2d0388671969c6290eb9323066c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines the type of the connected FX3 board.  <a href="main_8c.html#a3c4e2d0388671969c6290eb9323066c2">More...</a><br /></td></tr>
<tr class="separator:a3c4e2d0388671969c6290eb9323066c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979d0f023cb68d36fff95c5a5f5f2bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a979d0f023cb68d36fff95c5a5f5f2bc8">CyFxApplicationDefine</a> (void)</td></tr>
<tr class="memdesc:a979d0f023cb68d36fff95c5a5f5f2bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the RTOS kernel after booting and creates all the user threads.  <a href="main_8c.html#a979d0f023cb68d36fff95c5a5f5f2bc8">More...</a><br /></td></tr>
<tr class="separator:a979d0f023cb68d36fff95c5a5f5f2bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae17a9988f4fd3fff237c37d08ae4e6fe"><td class="memItemLeft" align="right" valign="top">CyU3PThread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ae17a9988f4fd3fff237c37d08ae4e6fe">StreamThread</a> = {0}</td></tr>
<tr class="separator:ae17a9988f4fd3fff237c37d08ae4e6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743ce2dd1d6ca6a49d6efdca91934bb"><td class="memItemLeft" align="right" valign="top">CyU3PThread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a2743ce2dd1d6ca6a49d6efdca91934bb">AppThread</a> = {0}</td></tr>
<tr class="separator:a2743ce2dd1d6ca6a49d6efdca91934bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9953443991a0dc77f0fa3cc0b0576a6"><td class="memItemLeft" align="right" valign="top">CyU3PEvent&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ae9953443991a0dc77f0fa3cc0b0576a6">EventHandler</a> = {0}</td></tr>
<tr class="separator:ae9953443991a0dc77f0fa3cc0b0576a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1de7c08a7670541c2253aac304c83"><td class="memItemLeft" align="right" valign="top">CyU3PEvent&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ae5d1de7c08a7670541c2253aac304c83">GpioHandler</a> = {0}</td></tr>
<tr class="separator:ae5d1de7c08a7670541c2253aac304c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aab9e931f1efc7d59b1fa758ee4454"><td class="memItemLeft" align="right" valign="top">CyU3PDmaChannel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ae8aab9e931f1efc7d59b1fa758ee4454">StreamingChannel</a> = {0}</td></tr>
<tr class="separator:ae8aab9e931f1efc7d59b1fa758ee4454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae013d67938ada41be97571e5df201ba0"><td class="memItemLeft" align="right" valign="top">CyU3PDmaChannel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ae013d67938ada41be97571e5df201ba0">ChannelFromPC</a> = {0}</td></tr>
<tr class="separator:ae013d67938ada41be97571e5df201ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2d4ec57f12b5985072f5cf000bbc0"><td class="memItemLeft" align="right" valign="top">CyU3PDmaChannel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a8ef2d4ec57f12b5985072f5cf000bbc0">ChannelToPC</a> = {0}</td></tr>
<tr class="separator:a8ef2d4ec57f12b5985072f5cf000bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f4fb79889fd9a2a5ef1e62e72c738"><td class="memItemLeft" align="right" valign="top">CyU3PDmaChannel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#af72f4fb79889fd9a2a5ef1e62e72c738">MemoryToSPI</a> = {0}</td></tr>
<tr class="separator:af72f4fb79889fd9a2a5ef1e62e72c738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495399a2f10b8f42901a3e592759685b"><td class="memItemLeft" align="right" valign="top">CyU3PDmaBuffer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a495399a2f10b8f42901a3e592759685b">ManualDMABuffer</a> = {0}</td></tr>
<tr class="separator:a495399a2f10b8f42901a3e592759685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed44eef5876251be24e1b418ea64590"><td class="memItemLeft" align="right" valign="top">CyU3PDmaBuffer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#aeed44eef5876251be24e1b418ea64590">SpiDmaBuffer</a> = {0}</td></tr>
<tr class="separator:aeed44eef5876251be24e1b418ea64590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb5735a48942c795b3be33a17c14eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_board_state.html">BoardState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#aadb5735a48942c795b3be33a17c14eb4">FX3State</a> = {.SpiConfig = {0}, .PinMap = {0}}</td></tr>
<tr class="separator:aadb5735a48942c795b3be33a17c14eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588a5b1b27013a3c880a0c031d6b7f3a"><td class="memItemLeft" align="right" valign="top">volatile CyBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a588a5b1b27013a3c880a0c031d6b7f3a">KillStreamEarly</a> = CyFalse</td></tr>
<tr class="separator:a588a5b1b27013a3c880a0c031d6b7f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98693015cd59e2346ce44ac5af02a4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_stream_state.html">StreamState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a98693015cd59e2346ce44ac5af02a4c0">StreamThreadState</a> = {0}</td></tr>
<tr class="separator:a98693015cd59e2346ce44ac5af02a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Entry point and setup functions for the Analog Devices iSensor FX3 Demonstration Platform firmware. </p>
<p>Copyright (c) Analog Devices Inc, 2018 - 2020 All Rights Reserved.</p>
<p>THIS SOFTWARE UTILIZES LIBRARIES DEVELOPED AND MAINTAINED BY CYPRESS INC. THE LICENSE INCLUDED IN THIS REPOSITORY DOES NOT EXTEND TO CYPRESS PROPERTY.</p>
<p>Use of this file is governed by the license agreement included in this repository.</p>
<dl class="section date"><dt>Date</dt><dd>8/1/2019 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>A. Nolan (<a href="#" onclick="location.href='mai'+'lto:'+'ale'+'x.'+'nol'+'an'+'@an'+'al'+'og.'+'co'+'m'; return false;">alex.<span style="display: none;">.nosp@m.</span>nola<span style="display: none;">.nosp@m.</span>n@ana<span style="display: none;">.nosp@m.</span>log.<span style="display: none;">.nosp@m.</span>com</a>) </dd>
<dd>
J. Chong (<a href="#" onclick="location.href='mai'+'lto:'+'jua'+'n.'+'cho'+'ng'+'@an'+'al'+'og.'+'co'+'m'; return false;">juan.<span style="display: none;">.nosp@m.</span>chon<span style="display: none;">.nosp@m.</span>g@ana<span style="display: none;">.nosp@m.</span>log.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4759bbcdd7e9e2d77fc72f1b1ed12c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4759bbcdd7e9e2d77fc72f1b1ed12c1a">&#9670;&nbsp;</a></span>AdiAppErrorHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiAppErrorHandler </td>
          <td>(</td>
          <td class="paramtype">CyU3PReturnStatus_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles critical errors generated by the ADI application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The error code which corresponds with the fatal error encountered during startup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function prints the error message to the debug console, waits five seconds, and performs a hard reset. Performing the hard reset will clear the SRAM and reboot the FX3 into the second stage iSensors FX3 bootloader. Could probably do something more intelligent, but at least this approach will not lock up the FX3 after a failed boot. </p>

</div>
</div>
<a id="a97ef5f1f7dd70bdb654bd2e0ed215a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ef5f1f7dd70bdb654bd2e0ed215a8e">&#9670;&nbsp;</a></span>AdiAppStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiAppStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets up the necessary resources to start the ADI application. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>The application startup process configures all GPIO and timers used by the firmware, as well as the USB endpoints, DMA controller, and SPI hardware. After all configuration is performed, the AppActive flag is set to true.</p>
<p>GPIO Clock configuration: SYS_CLK = 403.2MHz GPIO Fast Clock = SYS_CLK / 2 -&gt; 201.6MHz GPIO Slow Clock (Used for 10MHz timer) = Fast Clock / 20 -&gt; 10.08MHz Simple GPIO Sample Clock = Fast Clock / 2 -&gt; 100.8MHz </p>

</div>
</div>
<a id="a802d56f1d4d6c6e069d5bed2d01c2fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d56f1d4d6c6e069d5bed2d01c2fbd">&#9670;&nbsp;</a></span>AdiAppStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiAppStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called to shut down the application. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function cleans up the resources used by the ADI application and prepares them for the next run. Since this function is intended to be called as part of the shut down process, no error handling is performed. Any transient errors should be resolved the next time the system boots (after this function call is finished). </p>

</div>
</div>
<a id="a2407e9fc4f519060a25f5e6e79c9908e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2407e9fc4f519060a25f5e6e79c9908e">&#9670;&nbsp;</a></span>AdiBulkEndpointHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiBulkEndpointHandler </td>
          <td>(</td>
          <td class="paramtype">CyU3PUsbEpEvtType&#160;</td>
          <td class="paramname"><em>evType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CyU3PUSBSpeed_t&#160;</td>
          <td class="paramname"><em>usbSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles events generated by the bulk endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evType</td><td>The type of the event being handled</td></tr>
    <tr><td class="paramname">usbSpeed</td><td>The current connection speed</td></tr>
    <tr><td class="paramname">epNum</td><td>The end point number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>This function is currently unused. All event management to the host PC is performed through the control endpoint. </p>

</div>
</div>
<a id="a9a66ed1cd4bddfaee4a19ede70f94cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a66ed1cd4bddfaee4a19ede70f94cc1">&#9670;&nbsp;</a></span>AdiControlEndpointHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyBool_t AdiControlEndpointHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>setupdat0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>setupdat1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles events generated by the control endpoint. All vendor requests are handled in this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setupdat0</td><td>The first set of setup data. Contains of the request and value fields.</td></tr>
    <tr><td class="paramname">setupdat1</td><td>The second set of setup data. Contains the index and length fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the control endpoint event was handled properly.</dd></dl>
<p>This function handles all USB events generated by the control endpoint. For the iSensor FX3 firmware, these events are a set of custom vendor commands. These vendor commands must be issued by the host PC. To ensure consistent behavior, all vendor commands should be issued using a function call in the FX3API. The FX3 API manages the control endpoint parameters to ensure valid behavior in all cases.</p>
<p>Fast enumeration is used. Only requests addressed to the interface, class, vendor and unknown control requests are received by this function. </p>

</div>
</div>
<a id="a3c4e2d0388671969c6290eb9323066c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4e2d0388671969c6290eb9323066c2">&#9670;&nbsp;</a></span>AdiGetFX3BoardType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="main_8h.html#a5d0d41db1886fb75e6a09e4b74cdbc54">FX3BoardType</a> AdiGetFX3BoardType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines the type of the connected FX3 board. </p>
<dl class="section return"><dt>Returns</dt><dd>The connected board type. This can be a Cypress Explorer kit or iSensor FX3 board</dd></dl>
<p>This function works by measuring two ID pins which are assigned on the iSensor FX3 demonstration platform. These ID pins can be high, low, or tri-stated, allowing for 9 possible hardware ID configurations. The weak pull up / weak pull down functionality of the FX3 GPIO allows reliable differentiation between all three states. </p>

</div>
</div>
<a id="a0012feb7c1973f17875ca9c3458462bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0012feb7c1973f17875ca9c3458462bf">&#9670;&nbsp;</a></span>AdiGPIOEventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiGPIOEventHandler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gpioId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles GPIO interrupts and sets the appropriate flag in GpioHandler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpioId</td><td>The pin number of the pin which generated the interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function is called by the RTOS whenever the GPIO interrupt vector is enabled and a GPIO interrupt is received. Instead of performing any work in this function, to improve system responsiveness, this function sets an RTOS event flag, to be handled by the application thread. </p>

</div>
</div>
<a id="a2863fcc5229cc4a18aedee7cda44ea9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2863fcc5229cc4a18aedee7cda44ea9a">&#9670;&nbsp;</a></span>AdiLPMRequestHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyBool_t AdiLPMRequestHandler </td>
          <td>(</td>
          <td class="paramtype">CyU3PUsbLinkPowerMode&#160;</td>
          <td class="paramname"><em>link_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a callback function to handle Link Power Management (LPM) requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_mode</td><td>The USB link power state that is being set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true so that the USB driver always stays in high power state. </dd></dl>

</div>
</div>
<a id="af455227720659b28782283fa0cafc5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af455227720659b28782283fa0cafc5bc">&#9670;&nbsp;</a></span>AdiUSBEventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiUSBEventHandler </td>
          <td>(</td>
          <td class="paramtype">CyU3PUsbEventType_t&#160;</td>
          <td class="paramname"><em>evtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>evdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a callback function to handle generic USB events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evtype</td><td>The type of the event being handled</td></tr>
    <tr><td class="paramname">evdata</td><td>The data from the USB event</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles USB events by calling start/stop functions to manage the ADI application. </p>

</div>
</div>
<a id="add07376eecfcd79dfd9f998172675538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add07376eecfcd79dfd9f998172675538">&#9670;&nbsp;</a></span>BulkBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t BulkBuffer </td>
          <td>(</td>
          <td class="paramtype">(aligned(32))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>12KB Generic bulk buffer. Used for when data is manually sent to or received from the PC via bulk endpoints. </p>

</div>
</div>
<a id="a979d0f023cb68d36fff95c5a5f5f2bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979d0f023cb68d36fff95c5a5f5f2bc8">&#9670;&nbsp;</a></span>CyFxApplicationDefine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CyFxApplicationDefine </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the RTOS kernel after booting and creates all the user threads. </p>
<p>After the ThreadX kernel is started by a call to CyU3PKernelEntry() in main, this function is called. It creates the AppThread (for general execution / handling vendor requests) and the StreamThread for handling high throughput data streaming from a DUT. </p>

</div>
</div>
<a id="a1e4f00a6649f71b6f7d737b7906b7ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4f00a6649f71b6f7d737b7906b7ab3">&#9670;&nbsp;</a></span>FirmwareID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t FirmwareID </td>
          <td>(</td>
          <td class="paramtype">(aligned(32))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant firmware ID string. Manually updated when releasing new version of the FX3 firmware. Must match FX3 API version number. </p>

</div>
</div>
<a id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840291bc02cba5474a4cb46a9b9566fe">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the main entry point function for the iSensor FX3 application firmware. </p>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function. Should never return.</dd></dl>
<p>This firmware image is loaded into RAM over USB by the second-stange iSensor FX3 Bootloader when the Connect() function is called in the FX3 API. Once the full image has been loaded into SRAM, and the CRC verified, the iSensor FX3 bootloader jumps to this main function. Main initializes the device, memory, and IO matrix, and then boots the RTOS kernel. </p>

</div>
</div>
<a id="af944fb7c8896fdcd7f0d7d00f06fb329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af944fb7c8896fdcd7f0d7d00f06fb329">&#9670;&nbsp;</a></span>serial_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char serial_number </td>
          <td>(</td>
          <td class="paramtype">(aligned(32))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FX3 unique serial number. Set at runtime during the initialization process. </p>

</div>
</div>
<a id="aae2dfaf6e49d51d401e281fbdf83d874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2dfaf6e49d51d401e281fbdf83d874">&#9670;&nbsp;</a></span>USBBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBBuffer </td>
          <td>(</td>
          <td class="paramtype">(aligned(32))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>4KB USB Data buffer. Used to receive data from the control endpoint </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2743ce2dd1d6ca6a49d6efdca91934bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2743ce2dd1d6ca6a49d6efdca91934bb">&#9670;&nbsp;</a></span>AppThread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PThread AppThread = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTOS thread handle for the main application </p>

</div>
</div>
<a id="ae013d67938ada41be97571e5df201ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae013d67938ada41be97571e5df201ba0">&#9670;&nbsp;</a></span>ChannelFromPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaChannel ChannelFromPC = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA channel for BULK-OUT endpoint 0x1 (PC to FX3) </p>

</div>
</div>
<a id="a8ef2d4ec57f12b5985072f5cf000bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef2d4ec57f12b5985072f5cf000bbc0">&#9670;&nbsp;</a></span>ChannelToPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaChannel ChannelToPC = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA channel for BULK-IN endpoint 0x82 (FX3 to PC) </p>

</div>
</div>
<a id="ae9953443991a0dc77f0fa3cc0b0576a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9953443991a0dc77f0fa3cc0b0576a6">&#9670;&nbsp;</a></span>EventHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PEvent EventHandler = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADI event structure </p>

</div>
</div>
<a id="aadb5735a48942c795b3be33a17c14eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb5735a48942c795b3be33a17c14eb4">&#9670;&nbsp;</a></span>FX3State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_board_state.html">BoardState</a> FX3State = {.SpiConfig = {0}, .PinMap = {0}}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct. which stores all run time configurable FX3 settings </p>

</div>
</div>
<a id="ae5d1de7c08a7670541c2253aac304c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d1de7c08a7670541c2253aac304c83">&#9670;&nbsp;</a></span>GpioHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PEvent GpioHandler = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADI GPIO event structure (RTOS handles GPIO ISR) </p>

</div>
</div>
<a id="a588a5b1b27013a3c880a0c031d6b7f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588a5b1b27013a3c880a0c031d6b7f3a">&#9670;&nbsp;</a></span>KillStreamEarly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile CyBool_t KillStreamEarly = CyFalse</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal data stream thread to kill data capture early (True = kill thread signaled, False = allow execution) </p>

</div>
</div>
<a id="a495399a2f10b8f42901a3e592759685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495399a2f10b8f42901a3e592759685b">&#9670;&nbsp;</a></span>ManualDMABuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaBuffer_t ManualDMABuffer = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA buffer structure for output buffer </p>

</div>
</div>
<a id="af72f4fb79889fd9a2a5ef1e62e72c738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72f4fb79889fd9a2a5ef1e62e72c738">&#9670;&nbsp;</a></span>MemoryToSPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaChannel MemoryToSPI = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA channel for reading a memory location into a DMA consumer </p>

</div>
</div>
<a id="aeed44eef5876251be24e1b418ea64590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed44eef5876251be24e1b418ea64590">&#9670;&nbsp;</a></span>SpiDmaBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaBuffer_t SpiDmaBuffer = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA buffer structure for SPI transmit </p>

</div>
</div>
<a id="ae8aab9e931f1efc7d59b1fa758ee4454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8aab9e931f1efc7d59b1fa758ee4454">&#9670;&nbsp;</a></span>StreamingChannel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaChannel StreamingChannel = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA channel for real time streaming (SPI to USB BULK-IN 0x81) </p>

</div>
</div>
<a id="ae17a9988f4fd3fff237c37d08ae4e6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17a9988f4fd3fff237c37d08ae4e6fe">&#9670;&nbsp;</a></span>StreamThread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PThread StreamThread = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTOS thread handle for continuous data streaming functionality </p>

</div>
</div>
<a id="a98693015cd59e2346ce44ac5af02a4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98693015cd59e2346ce44ac5af02a4c0">&#9670;&nbsp;</a></span>StreamThreadState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_stream_state.html">StreamState</a> StreamThreadState = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct of data used to synchronize the data streaming / app threads </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
